// MasteringUtil_cxx.h
#pragma once
#include "MasteringUtil.h"
#include <cxx.h> // generated by cxx

#include <memory>
#include <string>
#include <vector>

namespace cxxbridge {

using MasteringUtility = ::MasteringUtility;
using MasteringUtilityMetadata = ::MasteringUtility::Metadata;
using MasteringUtilitySong = ::MasteringUtility::Song;
using MasteringUtilityAlbum = ::MasteringUtility::Album;

// MasteringUtility
inline std::unique_ptr<MasteringUtility> new_mastering_utility() {
    return std::make_unique<MasteringUtility>();
}

// Metadata
inline std::unique_ptr<MasteringUtilityMetadata> new_metadata() {
    return std::make_unique<MasteringUtilityMetadata>();
}

inline int metadata_get_id(const MasteringUtilityMetadata& m) { return m.ID; }
inline void metadata_set_id(MasteringUtilityMetadata& m, int id) { m.ID = id; }

inline const std::string& metadata_get_title(const MasteringUtilityMetadata& m) { return m.Title; }
inline void metadata_set_title(MasteringUtilityMetadata& m, const std::string& s) { m.Title = s; }

inline const std::string& metadata_get_artist(const MasteringUtilityMetadata& m) { return m.Artist; }
inline void metadata_set_artist(MasteringUtilityMetadata& m, const std::string& s) { m.Artist = s; }

inline const std::string& metadata_get_album(const MasteringUtilityMetadata& m) { return m.Album; }
inline void metadata_set_album(MasteringUtilityMetadata& m, const std::string& s) { m.Album = s; }

inline const std::string& metadata_get_genre(const MasteringUtilityMetadata& m) { return m.Genre; }
inline void metadata_set_genre(MasteringUtilityMetadata& m, const std::string& s) { m.Genre = s; }

inline const std::string& metadata_get_year(const MasteringUtilityMetadata& m) { return m.Year; }
inline void metadata_set_year(MasteringUtilityMetadata& m, const std::string& s) { m.Year = s; }

inline const std::string& metadata_get_comment(const MasteringUtilityMetadata& m) { return m.Comment; }
inline void metadata_set_comment(MasteringUtilityMetadata& m, const std::string& s) { m.Comment = s; }

inline const std::string& metadata_get_arguments(const MasteringUtilityMetadata& m) { return m.arguments; }
inline void metadata_set_arguments(MasteringUtilityMetadata& m, const std::string& s) { m.arguments = s; }

inline const std::string& metadata_get_copyright(const MasteringUtilityMetadata& m) { return m.Copyright; }
inline void metadata_set_copyright(MasteringUtilityMetadata& m, const std::string& s) { m.Copyright = s; }

inline std::string metadata_get_path(const MasteringUtilityMetadata& m) { return m.Path.string(); }
inline void metadata_set_path(MasteringUtilityMetadata& m, const std::string& s) { m.Path = s; }

inline std::string metadata_get_new_path(const MasteringUtilityMetadata& m) { return m.NewPath.string(); }
inline void metadata_set_new_path(MasteringUtilityMetadata& m, const std::string& s) { m.NewPath = s; }

// Song
inline std::unique_ptr<MasteringUtilitySong> new_song() {
    return std::make_unique<MasteringUtilitySong>();
}
inline int song_get_track_number(const MasteringUtilitySong& s) { return s.TrackNumber; }
inline void song_set_track_number(MasteringUtilitySong& s, int t) { s.TrackNumber = t; }

inline const std::string& song_get_codec(const MasteringUtilitySong& s) { return s.Codec; }
inline void song_set_codec(MasteringUtilitySong& s, const std::string& c) { s.Codec = c; }

// Album
inline std::unique_ptr<MasteringUtilityAlbum> new_album() {
    return std::make_unique<MasteringUtilityAlbum>();
}
inline std::string album_get_album_art(const MasteringUtilityAlbum& a) { return a.AlbumArt.string(); }
inline void album_set_album_art(MasteringUtilityAlbum& a, const std::string& s) { a.AlbumArt = s; }

inline std::vector<std::unique_ptr<MasteringUtilitySong>> album_get_songs(const MasteringUtilityAlbum& a) {
    std::vector<std::unique_ptr<MasteringUtilitySong>> v;
    for (const auto& song : a.SongsList) {
        v.push_back(std::make_unique<MasteringUtilitySong>(song));
    }
    return v;
}
inline void album_add_song(MasteringUtilityAlbum& a, std::unique_ptr<MasteringUtilitySong> song) {
    a.SongsList.push_back(*song);
}

// MasteringUtility methods
inline void Master(MasteringUtility& mu, const std::string& file) { mu.Master(file); }
inline void ProcessAlbum(MasteringUtility& mu, const MasteringUtilityAlbum& a) { mu.ProcessAlbum(a); }
inline void ProcessSong(MasteringUtility& mu, const MasteringUtilitySong& s, const MasteringUtilityAlbum& a) { mu.ProcessSong(s, a); }
inline void SaveMarkup(MasteringUtility& mu, const std::vector<std::unique_ptr<MasteringUtilityAlbum>>& albums, const std::string& file) {
    std::vector<MasteringUtility::Album> tmp;
    for (const auto& a : albums) tmp.push_back(*a);
    mu.SaveMarkup(tmp, file);
}
inline std::vector<std::unique_ptr<MasteringUtilityAlbum>> ParseMarkup(MasteringUtility& mu, const std::string& file) {
    std::vector<MasteringUtility::Album> tmp;
    mu.ParseMarkup(file, tmp);
    std::vector<std::unique_ptr<MasteringUtilityAlbum>> out;
    for (auto& a : tmp) out.push_back(std::make_unique<MasteringUtilityAlbum>(a));
    return out;
}

} // namespace cxxbridge
